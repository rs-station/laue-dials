<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>laue_dials.index &#8212; laue-dials</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=0ca6144b" />
    <script src="../_static/jquery.js?v=5d32c60e"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../_static/documentation_options.js?v=b04b8138"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="icon" href="../_static/rs-favicon_32x32.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="laue_dials.sequence_to_stills" href="sequence_to_stills.html" />
    <link rel="prev" title="laue_dials.find_spots" href="find_spots.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="laue-dials-index">
<span id="index"></span><h1>laue_dials.index<a class="headerlink" href="#laue-dials-index" title="Link to this heading"></a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<p>Perform monochromatic indexing and optional scan-varying refinement.</p>
<p>This program takes a DIALS imported experiment list (generated with
dials.import) and a strong reflection table and generates an initial
monochromatic indexing solution to feed into the remainder of the pipeline.
The outputs are a pair of files (monochromatic.expt, monochromatic.refl)
that constitute a monochromatic estimate of a geometric solution for the
experiment.</p>
<p>Examples:</p>
<blockquote>
<div><p>laue.index [options] imported.expt strong.refl</p>
</div></blockquote>
</section>
<section id="basic-parameters">
<h2>Basic parameters<a class="headerlink" href="#basic-parameters" title="Link to this heading"></a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">laue_output</span> <span class="p">{</span>
  <span class="n">index_only</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="n">final_output</span> <span class="p">{</span>
    <span class="n">experiments</span> <span class="o">=</span> <span class="s1">&#39;monochromatic.expt&#39;</span>
    <span class="n">reflections</span> <span class="o">=</span> <span class="s1">&#39;monochromatic.refl&#39;</span>
  <span class="p">}</span>
  <span class="n">indexed</span> <span class="p">{</span>
    <span class="n">experiments</span> <span class="o">=</span> <span class="s1">&#39;indexed.expt&#39;</span>
    <span class="n">reflections</span> <span class="o">=</span> <span class="s1">&#39;indexed.refl&#39;</span>
  <span class="p">}</span>
  <span class="n">refined</span> <span class="p">{</span>
    <span class="n">experiments</span> <span class="o">=</span> <span class="s1">&#39;refined.expt&#39;</span>
    <span class="n">reflections</span> <span class="o">=</span> <span class="s1">&#39;refined.refl&#39;</span>
  <span class="p">}</span>
  <span class="n">log</span> <span class="o">=</span> <span class="s1">&#39;laue.index.log&#39;</span>
<span class="p">}</span>
<span class="n">indexer</span> <span class="p">{</span>
  <span class="n">indexing</span> <span class="p">{</span>
    <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">known_symmetry</span> <span class="p">{</span>
      <span class="n">space_group</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">unit_cell</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">}</span>
    <span class="n">index_assignment</span> <span class="p">{</span>
      <span class="n">simple</span> <span class="p">{</span>
        <span class="n">hkl_tolerance</span> <span class="o">=</span> <span class="mf">0.3</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">check_misindexing</span> <span class="p">{</span>
      <span class="n">grid_search_scope</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="n">refinement_protocol</span> <span class="p">{</span>
      <span class="n">n_macro_cycles</span> <span class="o">=</span> <span class="mi">5</span>
      <span class="n">d_min_step</span> <span class="o">=</span> <span class="n">Auto</span>
      <span class="n">d_min_start</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">d_min_final</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">}</span>
    <span class="n">stills</span> <span class="p">{</span>
      <span class="n">ewald_proximity_resolution_cutoff</span> <span class="o">=</span> <span class="mf">2.0</span>
      <span class="n">refine_all_candidates</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="n">rmsd_min_px</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">ewald_proximal_volume_max</span> <span class="o">=</span> <span class="mf">0.0025</span>
      <span class="n">isoforms</span> <span class="p">{</span>
        <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">lookup_symbol</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">rmsd_target_mm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">beam_restraint</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="p">}</span>
      <span class="n">set_domain_size_ang_value</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">set_mosaic_half_deg_value</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">indexing</span> <span class="p">{</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">fft1d</span> <span class="o">*</span><span class="n">fft3d</span> <span class="n">real_space_grid_search</span> <span class="n">ffbidx</span> <span class="n">low_res_spot_match</span> \
             <span class="n">pink_indexer</span>
    <span class="n">image_range</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">joint_indexing</span> <span class="o">=</span> <span class="n">Auto</span>
  <span class="p">}</span>
  <span class="n">refinement</span> <span class="p">{</span>
    <span class="n">parameterisation</span> <span class="p">{</span>
      <span class="n">scan_varying</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">set_scan_varying_errors</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="n">beam</span> <span class="p">{</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="o">*</span><span class="nb">all</span> <span class="n">in_spindle_plane</span> <span class="n">out_spindle_plane</span> <span class="n">wavelength</span>
      <span class="p">}</span>
      <span class="n">crystal</span> <span class="p">{</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="nb">all</span> <span class="n">cell</span> <span class="n">orientation</span>
      <span class="p">}</span>
      <span class="n">detector</span> <span class="p">{</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="o">*</span><span class="nb">all</span> <span class="n">position</span> <span class="n">orientation</span> <span class="n">distance</span>
      <span class="p">}</span>
      <span class="n">goniometer</span> <span class="p">{</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="o">*</span><span class="nb">all</span> <span class="n">in_beam_plane</span> <span class="n">out_beam_plane</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">reflections</span> <span class="p">{</span>
      <span class="n">outlier</span> <span class="p">{</span>
        <span class="n">algorithm</span> <span class="o">=</span> <span class="n">null</span> <span class="n">auto</span> <span class="n">mcd</span> <span class="o">*</span><span class="n">tukey</span> <span class="n">sauter_poon</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">output</span> <span class="p">{</span>
    <span class="n">experiments</span> <span class="o">=</span> <span class="n">indexed</span><span class="o">.</span><span class="n">expt</span>
    <span class="n">reflections</span> <span class="o">=</span> <span class="n">indexed</span><span class="o">.</span><span class="n">refl</span>
    <span class="n">log</span> <span class="o">=</span> <span class="n">dials</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">log</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">refiner</span> <span class="p">{</span>
  <span class="n">output</span> <span class="p">{</span>
    <span class="n">experiments</span> <span class="o">=</span> <span class="n">refined</span><span class="o">.</span><span class="n">expt</span>
    <span class="n">reflections</span> <span class="o">=</span> <span class="n">refined</span><span class="o">.</span><span class="n">refl</span>
    <span class="n">log</span> <span class="o">=</span> <span class="n">dials</span><span class="o">.</span><span class="n">refine</span><span class="o">.</span><span class="n">log</span>
  <span class="p">}</span>
  <span class="n">n_static_macrocycles</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">separate_independent_sets</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="n">refinement</span> <span class="p">{</span>
    <span class="n">parameterisation</span> <span class="p">{</span>
      <span class="n">scan_varying</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="n">set_scan_varying_errors</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="n">beam</span> <span class="p">{</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="o">*</span><span class="nb">all</span> <span class="n">in_spindle_plane</span> <span class="n">out_spindle_plane</span> <span class="n">wavelength</span>
      <span class="p">}</span>
      <span class="n">crystal</span> <span class="p">{</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="nb">all</span> <span class="o">*</span><span class="n">cell</span> <span class="n">orientation</span>
      <span class="p">}</span>
      <span class="n">detector</span> <span class="p">{</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="nb">all</span> <span class="n">position</span> <span class="o">*</span><span class="n">orientation</span> <span class="n">distance</span>
      <span class="p">}</span>
      <span class="n">goniometer</span> <span class="p">{</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="nb">all</span> <span class="n">in_beam_plane</span> <span class="n">out_beam_plane</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">reflections</span> <span class="p">{</span>
      <span class="n">outlier</span> <span class="p">{</span>
        <span class="n">algorithm</span> <span class="o">=</span> <span class="n">null</span> <span class="n">auto</span> <span class="n">mcd</span> <span class="o">*</span><span class="n">tukey</span> <span class="n">sauter_poon</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="full-parameter-definitions">
<h2>Full parameter definitions<a class="headerlink" href="#full-parameter-definitions" title="Link to this heading"></a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">laue_output</span> <span class="p">{</span>
  <span class="n">index_only</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Whether to only index or also refine the data.&quot;</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
  <span class="n">final_output</span> <span class="p">{</span>
    <span class="n">experiments</span> <span class="o">=</span> <span class="s1">&#39;monochromatic.expt&#39;</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The final output experiment list filename.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
    <span class="n">reflections</span> <span class="o">=</span> <span class="s1">&#39;monochromatic.refl&#39;</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The final output reflection table filename.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
  <span class="p">}</span>
  <span class="n">indexed</span> <span class="p">{</span>
    <span class="n">experiments</span> <span class="o">=</span> <span class="s1">&#39;indexed.expt&#39;</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The output indexed experiment list filename.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
    <span class="n">reflections</span> <span class="o">=</span> <span class="s1">&#39;indexed.refl&#39;</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The output indexed reflection table filename.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
  <span class="p">}</span>
  <span class="n">refined</span> <span class="p">{</span>
    <span class="n">experiments</span> <span class="o">=</span> <span class="s1">&#39;refined.expt&#39;</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The output refined experiment list stills filename.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
    <span class="n">reflections</span> <span class="o">=</span> <span class="s1">&#39;refined.refl&#39;</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The output refined reflection table stills filename.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
  <span class="p">}</span>
  <span class="n">log</span> <span class="o">=</span> <span class="s1">&#39;laue.index.log&#39;</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The log filename.&quot;</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
<span class="p">}</span>
<span class="n">indexer</span> <span class="p">{</span>
  <span class="n">indexing</span> <span class="p">{</span>
    <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The number of processes to use.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">mm_search_scope</span> <span class="o">=</span> <span class="mf">4.0</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Global radius of origin offset search.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">wide_search_binning</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Modify the coarseness of the wide grid search for the beam&quot;</span>
              <span class="s2">&quot;centre.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">min_cell_volume</span> <span class="o">=</span> <span class="mi">25</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Minimum unit cell volume (in Angstrom^3).&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">min_cell</span> <span class="o">=</span> <span class="mi">3</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Minimum length of candidate unit cell basis vectors (in&quot;</span>
              <span class="s2">&quot;Angstrom).&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">max_cell</span> <span class="o">=</span> <span class="n">Auto</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum length of candidate unit cell basis vectors (in&quot;</span>
              <span class="s2">&quot;Angstrom).&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">max_cell_estimation</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">filter_ice</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Filter out reflections at typical ice ring resolutions before&quot;</span>
                <span class="s2">&quot;max_cell estimation.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">filter_overlaps</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Filter out reflections with overlapping bounding boxes before&quot;</span>
                <span class="s2">&quot;max_cell estimation.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">overlaps_border</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Optionally add a border around the bounding boxes before&quot;</span>
                <span class="s2">&quot;finding overlaps.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">multiplier</span> <span class="o">=</span> <span class="mf">1.3</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Multiply the estimated maximum basis vector length by this&quot;</span>
                <span class="s2">&quot;value.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">step_size</span> <span class="o">=</span> <span class="mi">45</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Step size, in degrees, of the blocks used to perform the&quot;</span>
                <span class="s2">&quot;max_cell  estimation.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">nearest_neighbor_percentile</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Percentile of NN histogram to use for max cell determination.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">histogram_binning</span> <span class="o">=</span> <span class="n">linear</span> <span class="o">*</span><span class="n">log</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Choose between linear or logarithmic bins for nearest&quot;</span>
                <span class="s2">&quot;neighbour histogram analysis.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="n">nn_per_bin</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Target number of nearest neighbours per histogram bin.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">max_height_fraction</span> <span class="o">=</span> <span class="mf">0.25</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="p">}</span>
    <span class="n">sigma_phi_deg</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Override the phi sigmas for refinement. Mainly intended for&quot;</span>
              <span class="s2">&quot;single-shot rotation images where the phi sigma is almost&quot;</span>
              <span class="s2">&quot;certainly incorrect.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">known_symmetry</span> <span class="p">{</span>
      <span class="n">space_group</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Target space group for indexing.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">space_group</span>
      <span class="n">unit_cell</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Target unit cell for indexing.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">unit_cell</span>
      <span class="n">relative_length_tolerance</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Relative tolerance for unit cell lengths in unit cell&quot;</span>
                <span class="s2">&quot;comparison.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">absolute_angle_tolerance</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Angular tolerance (in degrees) in unit cell comparison.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">max_delta</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum allowed Le Page delta used in searching for basis&quot;</span>
                <span class="s2">&quot;vector combinations that are consistent with the given&quot;</span>
                <span class="s2">&quot;symmetry.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="n">index_assignment</span> <span class="p">{</span>
      <span class="n">method</span> <span class="o">=</span> <span class="o">*</span><span class="n">simple</span> <span class="n">local</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Choose between simple &#39;global&#39; index assignment and xds-style&quot;</span>
                <span class="s2">&quot; &#39;local&#39; index assignment.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">simple</span> <span class="p">{</span>
        <span class="n">hkl_tolerance</span> <span class="o">=</span> <span class="mf">0.3</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum allowable deviation from integer-ness for assigning&quot;</span>
                  <span class="s2">&quot; a miller index to a reciprocal lattice vector.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="n">local</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">{</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.05</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;This corresponds to the xds parameter INDEX_ERROR=&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mi">8</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;This corresponds to the xds parameter INDEX_MAGNITUDE=&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">l_min</span> <span class="o">=</span> <span class="mf">0.8</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;This corresponds to the xds parameter INDEX_QUALITY=&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">nearest_neighbours</span> <span class="o">=</span> <span class="mi">20</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">check_misindexing</span> <span class="p">{</span>
      <span class="n">grid_search_scope</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Search scope for testing misindexing on h, k, l.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">combine_scans</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">refinement_protocol</span> <span class="p">{</span>
      <span class="n">mode</span> <span class="o">=</span> <span class="o">*</span><span class="n">refine_shells</span> <span class="n">repredict_only</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;refine_shells: if using sequences indexer, refine in&quot;</span>
                <span class="s2">&quot;increasing resolution cutoffs after indexing, if using stills&quot;</span>
                <span class="s2">&quot;indexer, refine all data up to d_min_start resolution once&quot;</span>
                <span class="s2">&quot;only. repredict_only: do not refine after indexing, just&quot;</span>
                <span class="s2">&quot;update spot predictions. None: do not refine and do not&quot;</span>
                <span class="s2">&quot;update spot predictions.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">n_macro_cycles</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of macro cycles of refinement, reindexing all&quot;</span>
                <span class="s2">&quot;reflections using updated geometry at the beginning of each&quot;</span>
                <span class="s2">&quot;cycle. Does not apply to stills.indexer=stills.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">d_min_step</span> <span class="o">=</span> <span class="n">Auto</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Reduction per step in d_min for reflections to include in&quot;</span>
                <span class="s2">&quot;refinement. Does not apply to stills.indexer=stills.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">d_min_start</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;For sequences/stills indexer, the lower limit of d-spacing of&quot;</span>
                <span class="s2">&quot;reflections used in the first/the only round of refinement.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">d_min_final</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Do not ever include reflections below this value in&quot;</span>
                <span class="s2">&quot;refinement. Does not apply to stills.indexer=stills.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">disable_unit_cell_volume_sanity_check</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Disable sanity check on unrealistic increases in unit cell&quot;</span>
                <span class="s2">&quot;volume during refinement. Does not apply to&quot;</span>
                <span class="s2">&quot;stills.indexer=stills.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="n">multiple_lattice_search</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">recycle_unindexed_reflections_cutoff</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Attempt another cycle of indexing on the unindexed&quot;</span>
                <span class="s2">&quot;reflections  if more than the fraction of input reflections&quot;</span>
                <span class="s2">&quot;are unindexed.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">minimum_angular_separation</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The minimum angular separation (in degrees) between two&quot;</span>
                <span class="s2">&quot;lattices.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">max_lattices</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">cluster_analysis</span> <span class="p">{</span>
        <span class="n">method</span> <span class="o">=</span> <span class="o">*</span><span class="n">dbscan</span> <span class="n">hcluster</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="n">hcluster</span> <span class="p">{</span>
          <span class="n">linkage</span> <span class="p">{</span>
            <span class="n">method</span> <span class="o">=</span> <span class="o">*</span><span class="n">ward</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="o">*</span><span class="n">euclidean</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
          <span class="p">}</span>
          <span class="n">cutoff</span> <span class="o">=</span> <span class="mi">15</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">cutoff_criterion</span> <span class="o">=</span> <span class="o">*</span><span class="n">distance</span> <span class="n">inconsistent</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="p">}</span>
        <span class="n">dbscan</span> <span class="p">{</span>
          <span class="n">eps</span> <span class="o">=</span> <span class="mf">0.05</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">min_samples</span> <span class="o">=</span> <span class="mi">30</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">min_cluster_size</span> <span class="o">=</span> <span class="mi">20</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">intersection_union_ratio_cutoff</span> <span class="o">=</span> <span class="mf">0.4</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">stills</span> <span class="p">{</span>
      <span class="n">indexer</span> <span class="o">=</span> <span class="o">*</span><span class="n">Auto</span> <span class="n">stills</span> <span class="n">sequences</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Use the stills or sequences indexer. Auto: choose based on&quot;</span>
                <span class="s2">&quot;the input imagesets (stills or sequences).&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">ewald_proximity_resolution_cutoff</span> <span class="o">=</span> <span class="mf">2.0</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;the acceptable volume of reciprocal space for spot prediction&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">refine_all_candidates</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If False, no attempt is made to refine the model from initial&quot;</span>
                <span class="s2">&quot;basis vector selection. The indexing solution with the best&quot;</span>
                <span class="s2">&quot;RMSD is chosen.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">candidate_outlier_rejection</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If True, while refining candidate basis solutions, also apply&quot;</span>
                <span class="s2">&quot;Sauter/ Poon (2010) outlier rejection&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">refine_candidates_with_known_symmetry</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If False, when choosing the best set of candidate basis&quot;</span>
                <span class="s2">&quot;solutions, refine the candidates in the P1 setting. If True,&quot;</span>
                <span class="s2">&quot;after indexing in P1, convert the candidates to the known&quot;</span>
                <span class="s2">&quot;symmetry and apply the corresponding change of basis to the&quot;</span>
                <span class="s2">&quot;indexed reflections.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">rmsd_min_px</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Minimum acceptable RMSD for choosing candidate basis&quot;</span>
                <span class="s2">&quot;solutions (in pixels)&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">ewald_proximal_volume_max</span> <span class="o">=</span> <span class="mf">0.0025</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum acceptable ewald proximal volume when choosing&quot;</span>
                <span class="s2">&quot;candidate basis solutions&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">isoforms</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Constrain the unit cell to specific values during refinement&quot;</span>
                <span class="s2">&quot;after initial indexing.&quot;</span>
        <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="p">{</span>
        <span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">unit_cell</span>
        <span class="n">lookup_symbol</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The sgtbx lookup symbol of the reflections pointgroup&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="n">rmsd_target_mm</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum acceptable DIALS positional rmsd, in mm&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">beam_restraint</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;to assure that no images are accepted where the lattice is&quot;</span>
                  <span class="s2">&quot;misindexed by a unit shift.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="n">set_domain_size_ang_value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If specified, will set the domain size ang value and override&quot;</span>
                <span class="s2">&quot;the value determined from nave refinement&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">set_mosaic_half_deg_value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If specified, will set the mosaic half degree value and&quot;</span>
                <span class="s2">&quot;override the value determined from nave refinement&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">indexing</span> <span class="p">{</span>
    <span class="n">basis_vector_combinations</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">max_combinations</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of basis vector combinations to test for&quot;</span>
                <span class="s2">&quot;agreement with input symmetry.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">max_refine</span> <span class="o">=</span> <span class="n">Auto</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of putative crystal models to test. Default&quot;</span>
                <span class="s2">&quot;for rotation sequences: 50, for still images: 5&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">sys_absent_threshold</span> <span class="o">=</span> <span class="mf">0.9</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">solution_scorer</span> <span class="o">=</span> <span class="nb">filter</span> <span class="o">*</span><span class="n">weighted</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="nb">filter</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">{</span>
        <span class="n">check_doubled_cell</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="n">likelihood_cutoff</span> <span class="o">=</span> <span class="mf">0.8</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">volume_cutoff</span> <span class="o">=</span> <span class="mf">1.25</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">n_indexed_cutoff</span> <span class="o">=</span> <span class="mf">0.9</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="n">weighted</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">{</span>
        <span class="n">power</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">volume_weight</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">n_indexed_weight</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">rmsd_weight</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">fft1d</span> <span class="o">*</span><span class="n">fft3d</span> <span class="n">real_space_grid_search</span> <span class="n">ffbidx</span> <span class="n">low_res_spot_match</span> \
             <span class="n">pink_indexer</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
    <span class="n">optimise_initial_basis_vectors</span> <span class="o">=</span> <span class="kc">False</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">fft1d</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Search for the basis vectors of the direct lattice by&quot;</span>
              <span class="s2">&quot;performing a series of 1D FFTs along various directions in&quot;</span>
              <span class="s2">&quot;reciprocal space. This has a lower memory requirement than a&quot;</span>
              <span class="s2">&quot;single 3D FFT (the fft3d method). This method may also be more&quot;</span>
              <span class="s2">&quot;appropriate than a 3D FFT if the reflections are from narrow&quot;</span>
              <span class="s2">&quot;wedges of rotation data or from stills data.&quot;</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">characteristic_grid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Sampling frequency in radians. See Steller 1997. If None,&quot;</span>
                <span class="s2">&quot;determine a grid sampling automatically using the input&quot;</span>
                <span class="s2">&quot;reflections, using at most 0.029 radians.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">fft3d</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Search for the basis vectors of the direct lattice by&quot;</span>
              <span class="s2">&quot;performing a 3D FFT in reciprocal space of the density of found&quot;</span>
              <span class="s2">&quot;spots. Since this can be quite memory-intensive, the data used&quot;</span>
              <span class="s2">&quot;for indexing may automatically be constrained to just the lower&quot;</span>
              <span class="s2">&quot;resolution spots.&quot;</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">b_iso</span> <span class="o">=</span> <span class="n">Auto</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">rmsd_cutoff</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">peak_search</span> <span class="o">=</span> <span class="o">*</span><span class="n">flood_fill</span> <span class="n">clean</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">peak_volume_cutoff</span> <span class="o">=</span> <span class="mf">0.15</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">reciprocal_space_grid</span> <span class="p">{</span>
        <span class="n">n_points</span> <span class="o">=</span> <span class="mi">256</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">d_min</span> <span class="o">=</span> <span class="n">Auto</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The high resolution limit in Angstrom for spots to include&quot;</span>
                  <span class="s2">&quot;in  the initial indexing.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">real_space_grid_search</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Index the found spots by testing a known unit cell in various&quot;</span>
              <span class="s2">&quot;orientations until the best match is found. This strategy is&quot;</span>
              <span class="s2">&quot;often useful for difficult cases of narrow-wedge rotation data&quot;</span>
              <span class="s2">&quot;or stills data, especially where there is diffraction from&quot;</span>
              <span class="s2">&quot;multiple crystals.&quot;</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">characteristic_grid</span> <span class="o">=</span> <span class="mf">0.02</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">max_vectors</span> <span class="o">=</span> <span class="mi">30</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The maximum number of unique vectors to find in the grid&quot;</span>
                <span class="s2">&quot;search.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">ffbidx</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;A lattice search strategy for very fast indexing using Cuda&quot;</span>
              <span class="s2">&quot;acceleration&quot;</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">max_output_cells</span> <span class="o">=</span> <span class="mi">32</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of output cells&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">max_spots</span> <span class="o">=</span> <span class="mi">300</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of reciprocal spots taken into account&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">num_candidate_vectors</span> <span class="o">=</span> <span class="mi">32</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of candidate cell vectors&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">redundant_computations</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Calculate candidates for all three cell vectors&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">dist1</span> <span class="o">=</span> <span class="mf">0.3</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Reciprocal spots within this threshold contribute to the&quot;</span>
                <span class="s2">&quot;score for vector sampling&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">dist3</span> <span class="o">=</span> <span class="mf">0.15</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Reciprocal spots within this threshold contribute to the&quot;</span>
                <span class="s2">&quot;score for cell sampling&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">num_halfsphere_points</span> <span class="o">=</span> <span class="mi">32768</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of sampling points on the half sphere&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">8000</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">max_dist</span> <span class="o">=</span> <span class="mf">0.00075</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum final distance between measured and calculated&quot;</span>
                <span class="s2">&quot;reciprocal spot&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">min_spots</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Minimum number of reciprocal spots within distance max_dist&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">method</span> <span class="o">=</span> <span class="o">*</span><span class="n">ifssr</span> <span class="n">ifss</span> <span class="n">ifse</span> <span class="n">raw</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Refinement method (consult algorithm description)&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="n">triml</span> <span class="o">=</span> <span class="mf">0.001</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;lower trimming value for intermediate score calculations&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">trimh</span> <span class="o">=</span> <span class="mf">0.3</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;higher trimming value for intermediate score calculations&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">delta</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;log2 curve position for intermediate score calculations,&quot;</span>
                <span class="s2">&quot;lower values will me more selective in choosing close spots&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mf">1e-06</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">simple_data_filename</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Optional filename for the output of a simple data file for&quot;</span>
                <span class="s2">&quot;debugging&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">path</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="p">}</span>
    <span class="n">low_res_spot_match</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;A lattice search strategy that matches low resolution spots to&quot;</span>
              <span class="s2">&quot;candidate indices based on a known unit cell and space group.&quot;</span>
              <span class="s2">&quot;Designed primarily for electron diffraction still images.&quot;</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">candidate_spots</span> <span class="p">{</span>
        <span class="n">limit_resolution_by</span> <span class="o">=</span> <span class="o">*</span><span class="n">n_spots</span> <span class="n">d_min</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="n">d_min</span> <span class="o">=</span> <span class="mf">15.0</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">n_spots</span> <span class="o">=</span> <span class="mi">10</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">d_star_tolerance</span> <span class="o">=</span> <span class="mf">4.0</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of sigmas from the centroid position for which to &quot;</span>
                  <span class="s2">&quot;calculate d* bands&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="n">use_P1_indices_as_seeds</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">search_depth</span> <span class="o">=</span> <span class="o">*</span><span class="n">triplets</span> <span class="n">quads</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="n">bootstrap_crystal</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">max_pairs</span> <span class="o">=</span> <span class="mi">200</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">max_triplets</span> <span class="o">=</span> <span class="mi">600</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">max_quads</span> <span class="o">=</span> <span class="mi">600</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">pink_indexer</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;A lattice search strategy that matches low resolution spots to&quot;</span>
              <span class="s2">&quot;candidate indices based on a known unit cell and space group.&quot;</span>
              <span class="s2">&quot;It supports mono and polychromatic beams.&quot;</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">max_refls</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of reflections to consider indexing&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">wavelength</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The peak wavelength&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">percent_bandwidth</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The percent bandwidth used to calculate the wavelength range&quot;</span>
                <span class="s2">&quot;for indexing. The wavelength range is defined (wavelength -&quot;</span>
                <span class="s2">&quot;wavelength*percent_bandwidth/200, wavelength +&quot;</span>
                <span class="s2">&quot;wavelength*percent_bandwidth/200). This parameter also&quot;</span>
                <span class="s2">&quot;reflects the uncertainty of the supplied cell constants with&quot;</span>
                <span class="s2">&quot;larger values appropriate for less certain unit cells.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">rotogram_grid_points</span> <span class="o">=</span> <span class="mi">180</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of points at which to evaluate the angle search for&quot;</span>
                <span class="s2">&quot;each rlp-observation pair&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">voxel_grid_points</span> <span class="o">=</span> <span class="mi">150</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Controls the number of voxels onto which the rotograms are&quot;</span>
                <span class="s2">&quot;discretized&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">min_lattices</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The minimum number of candidate lattices to generate.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">image_range</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Range in images to slice a sequence. The number of arguments&quot;</span>
              <span class="s2">&quot;must be a factor of two. Each pair of arguments gives a range&quot;</span>
              <span class="s2">&quot;that follows C conventions (e.g. j0 &lt;= j &lt; j1) when slicing the&quot;</span>
              <span class="s2">&quot;reflections by observed centroid.&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
      <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">joint_indexing</span> <span class="o">=</span> <span class="n">Auto</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
  <span class="p">}</span>
  <span class="n">refinement</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters to configure the refinement&quot;</span>
  <span class="p">{</span>
    <span class="n">mp</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="p">{</span>
      <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The number of processes to use. Not all choices of refinement&quot;</span>
                <span class="s2">&quot;engine support nproc &gt; 1. Where multiprocessing is possible,&quot;</span>
                <span class="s2">&quot;it is helpful only in certain circumstances, so this is not&quot;</span>
                <span class="s2">&quot;recommended for typical use.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">parameterisation</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters to control the parameterisation of experimental&quot;</span>
              <span class="s2">&quot;models&quot;</span>
    <span class="p">{</span>
      <span class="n">auto_reduction</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;determine behaviour when there are too few reflections to&quot;</span>
                <span class="s2">&quot;reasonably produce a full parameterisation of the experiment&quot;</span>
                <span class="s2">&quot;list&quot;</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">{</span>
        <span class="n">min_nref_per_parameter</span> <span class="o">=</span> <span class="mi">5</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;the smallest number of reflections per parameter for a&quot;</span>
                  <span class="s2">&quot;model parameterisation below which the parameterisation&quot;</span>
                  <span class="s2">&quot;will not be made in full, but the action described below&quot;</span>
                  <span class="s2">&quot;will be triggered.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">action</span> <span class="o">=</span> <span class="o">*</span><span class="n">fail</span> <span class="n">fix</span> <span class="n">remove</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;action to take if there are too few reflections across the&quot;</span>
                  <span class="s2">&quot;experiments related to a particular model parameterisation.&quot;</span>
                  <span class="s2">&quot;If fail, an exception will be raised and refinement will&quot;</span>
                  <span class="s2">&quot;not proceed. If fix, refinement will continue but with the&quot;</span>
                  <span class="s2">&quot;parameters relating to that model remaining fixed at their&quot;</span>
                  <span class="s2">&quot;initial values. If remove, parameters relating to that&quot;</span>
                  <span class="s2">&quot;model will be fixed, and in addition all reflections&quot;</span>
                  <span class="s2">&quot;related to that parameterisation will be removed. This will&quot;</span>
                  <span class="s2">&quot;therefore remove these reflections from other&quot;</span>
                  <span class="s2">&quot;parameterisations of the global model too. For example, if&quot;</span>
                  <span class="s2">&quot;a crystal model could not be parameterised it will be&quot;</span>
                  <span class="s2">&quot;excised completely and not contribute to the joint&quot;</span>
                  <span class="s2">&quot;refinement of the detector and beam. In the fix mode,&quot;</span>
                  <span class="s2">&quot;reflections emanating from that crystal will still form&quot;</span>
                  <span class="s2">&quot;residuals and will contribute to detector and beam&quot;</span>
                  <span class="s2">&quot;refinement.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="p">}</span>
      <span class="n">scan_varying</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Allow models that are not forced to be static to vary during&quot;</span>
                <span class="s2">&quot;the scan, Auto will run one macrocycle with static then scan&quot;</span>
                <span class="s2">&quot;varying refinement for the crystal&quot;</span>
        <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Scan-varying refinement&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Overall default value of the width of scan between&quot;</span>
                <span class="s2">&quot;checkpoints in degrees for scan-varying refinement. If set to&quot;</span>
                <span class="s2">&quot;None, each model will use its own specified value.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">compose_model_per</span> <span class="o">=</span> <span class="n">image</span> <span class="o">*</span><span class="n">block</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;For scan-varying parameterisations, compose a new model&quot;</span>
                <span class="s2">&quot;either every image or within blocks of a width specified in&quot;</span>
                <span class="s2">&quot;the reflections parameters. When this block width is larger&quot;</span>
                <span class="s2">&quot;than the image width the result is faster, with a trade-off&quot;</span>
                <span class="s2">&quot;in accuracy&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">block_width</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of a reflection &#39;block&#39; (in degrees) determining how&quot;</span>
                <span class="s2">&quot;fine- grained the model used for scan-varying prediction&quot;</span>
                <span class="s2">&quot;during refinement is. Currently only has any effect if the&quot;</span>
                <span class="s2">&quot;crystal parameterisation is set to use&quot;</span>
                <span class="s2">&quot;compose_model_per=block&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">set_scan_varying_errors</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If scan-varying refinement is done, and if the estimated&quot;</span>
                <span class="s2">&quot;covariance of the model states have been calculated by the&quot;</span>
                <span class="s2">&quot;minimiser, choose whether to return this to the models or&quot;</span>
                <span class="s2">&quot;not. The default is not to, in order to keep the file size of&quot;</span>
                <span class="s2">&quot;the serialized model small. At the moment, this only has an&quot;</span>
                <span class="s2">&quot;effect for crystal unit cell (B matrix) errors.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">trim_scan_to_observations</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;For scan-varying refinement, trim scan objects to the range&quot;</span>
                <span class="s2">&quot;of observed reflections. This avoids failures in refinement&quot;</span>
                <span class="s2">&quot;for cases where the extremes of scans contain no data, such&quot;</span>
                <span class="s2">&quot;as when the crystal moves out of the beam.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">debug_centroid_analysis</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Set True to write out a file containing the reflections used&quot;</span>
                <span class="s2">&quot;for centroid analysis for automatic setting of the &quot;</span>
                <span class="s2">&quot;scan-varying interval width. This can then be analysed with&quot;</span>
                <span class="s2">&quot;dev.dials.plot_centroid_analysis (requires dials_scratch&quot;</span>
                <span class="s2">&quot;repository).&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">beam</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;beam parameters&quot;</span>
      <span class="p">{</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="o">*</span><span class="nb">all</span> <span class="n">in_spindle_plane</span> <span class="n">out_spindle_plane</span> <span class="n">wavelength</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Whether to fix beam parameters. By default,&quot;</span>
                  <span class="s2">&quot;in_spindle_plane is selected, and one of the two parameters&quot;</span>
                  <span class="s2">&quot;is fixed. If a goniometer is present this leads to the beam&quot;</span>
                  <span class="s2">&quot;orientation being restricted to a direction in the initial&quot;</span>
                  <span class="s2">&quot;spindle-beam plane. Wavelength is also fixed by default, to&quot;</span>
                  <span class="s2">&quot;allow refinement of the unit cell volume.&quot;</span>
          <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Fix beam parameters&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span><span class="p">(</span><span class="n">multi</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fix_list</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix specified parameters by a list of 0-based indices or&quot;</span>
                  <span class="s2">&quot;partial names to match&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">constraints</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameter equal shift constraints to use in refinement.&quot;</span>
          <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="p">{</span>
          <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                    <span class="s2">&quot;which parameterisations to apply the constraint to. If an&quot;</span>
                    <span class="s2">&quot;identified parameterisation affects multiple experiments&quot;</span>
                    <span class="s2">&quot;then the index of any one of those experiments suffices&quot;</span>
                    <span class="s2">&quot;to identify that parameterisation. If None (the default)&quot;</span>
                    <span class="s2">&quot;then constraints will be applied to all parameterisations&quot;</span>
                    <span class="s2">&quot;of this type.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
          <span class="n">parameter</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Identify which parameter of each parameterisation to&quot;</span>
                    <span class="s2">&quot;constrain by a (partial) parameter name to match. Model&quot;</span>
                    <span class="s2">&quot;name prefixes such as &#39;Detector1&#39; will be ignored as&quot;</span>
                    <span class="s2">&quot;parameterisations are already identified by experiment id&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="p">}</span>
        <span class="n">force_static</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Force a static parameterisation for the beam when doing&quot;</span>
                  <span class="s2">&quot;scan-varying refinement&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">smoother</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options that affect scan-varying parameterisation&quot;</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="mf">36.0</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of scan between checkpoints in degrees. Can be set&quot;</span>
                    <span class="s2">&quot;to Auto.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">absolute_num_intervals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of intervals between checkpoints if scan_varying&quot;</span>
                    <span class="s2">&quot;refinement is requested. If set, this overrides&quot;</span>
                    <span class="s2">&quot;interval_width_degrees&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">crystal</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;crystal parameters&quot;</span>
      <span class="p">{</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="nb">all</span> <span class="n">cell</span> <span class="n">orientation</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix crystal parameters&quot;</span>
          <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Fix crystal parameters&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="n">unit_cell</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">fix_list</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix specified parameters by a list of 0-based indices or&quot;</span>
                    <span class="s2">&quot;partial names to match&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="n">restraints</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Least squares unit cell restraints to use in refinement.&quot;</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="p">{</span>
            <span class="n">tie_to_target</span>
              <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="p">{</span>
              <span class="n">values</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Target unit cell parameters for the restraint for&quot;</span>
                        <span class="s2">&quot;this parameterisation&quot;</span>
                <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
              <span class="n">sigmas</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The unit cell target values are associated with&quot;</span>
                        <span class="s2">&quot;sigmas which are used to determine the weight of each&quot;</span>
                        <span class="s2">&quot;restraint. A sigma of zero will remove the restraint&quot;</span>
                        <span class="s2">&quot;at that position. If symmetry constrains two cell&quot;</span>
                        <span class="s2">&quot;dimensions to be equal then only the smaller of the&quot;</span>
                        <span class="s2">&quot;two sigmas will be kept&quot;</span>
                <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
              <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                        <span class="s2">&quot;which parameterisations to apply these restraints to.&quot;</span>
                        <span class="s2">&quot;If an identified parameterisation affects multiple&quot;</span>
                        <span class="s2">&quot;experiments then the index of any one of those&quot;</span>
                        <span class="s2">&quot;experiments suffices to restrain that&quot;</span>
                        <span class="s2">&quot;parameterisation. If None (the default) then the&quot;</span>
                        <span class="s2">&quot;restraints will be applied to all experiments.&quot;</span>
                <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">tie_to_group</span>
              <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="p">{</span>
              <span class="n">target</span> <span class="o">=</span> <span class="o">*</span><span class="n">mean</span> <span class="n">low_memory_mean</span> <span class="n">median</span>
                <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Function to tie group parameter values to&quot;</span>
                <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
              <span class="n">sigmas</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The unit cell parameters are associated with sigmas&quot;</span>
                        <span class="s2">&quot;which are used to determine the weight of each&quot;</span>
                        <span class="s2">&quot;restraint. A sigma of zero will remove the restraint&quot;</span>
                        <span class="s2">&quot;at that position.&quot;</span>
                <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
              <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                        <span class="s2">&quot;which  parameterisations to apply these restraints&quot;</span>
                        <span class="s2">&quot;to. For every parameterisation that requires a&quot;</span>
                        <span class="s2">&quot;restraint at least one experiment index must be&quot;</span>
                        <span class="s2">&quot;supplied. If None (the default) the restraints will&quot;</span>
                        <span class="s2">&quot;be applied to all experiments.&quot;</span>
                <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">}</span>
          <span class="p">}</span>
          <span class="n">constraints</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameter equal shift constraints to use in refinement.&quot;</span>
            <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
          <span class="p">{</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                      <span class="s2">&quot;which parameterisations to apply the constraint to. If&quot;</span>
                      <span class="s2">&quot;an identified parameterisation affects multiple&quot;</span>
                      <span class="s2">&quot;experiments then the index of any one of those&quot;</span>
                      <span class="s2">&quot;experiments suffices to identify that parameterisation.&quot;</span>
                      <span class="s2">&quot;If None (the default) then constraints will be applied&quot;</span>
                      <span class="s2">&quot;to all parameterisations of this type.&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Identify which parameter of each parameterisation to&quot;</span>
                      <span class="s2">&quot;constrain by a (partial) parameter name to match. Model&quot;</span>
                      <span class="s2">&quot;name prefixes such as &#39;Detector1&#39; will be ignored as&quot;</span>
                      <span class="s2">&quot;parameterisations are already identified by experiment&quot;</span>
                      <span class="s2">&quot;id&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
          <span class="p">}</span>
          <span class="n">force_static</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Force a static parameterisation for the crystal unit cell&quot;</span>
                    <span class="s2">&quot;when doing scan-varying refinement&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="n">smoother</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options that affect scan-varying parameterisation&quot;</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="p">{</span>
            <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="mf">36.0</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of scan between checkpoints in degrees. Can be&quot;</span>
                      <span class="s2">&quot;set to Auto.&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">absolute_num_intervals</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of intervals between checkpoints if scan_varying&quot;</span>
                      <span class="s2">&quot;refinement is requested. If set, this overrides&quot;</span>
                      <span class="s2">&quot;interval_width_degrees&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">orientation</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">fix_list</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix specified parameters by a list of 0-based indices or&quot;</span>
                    <span class="s2">&quot;partial names to match&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="n">constraints</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameter equal shift constraints to use in refinement.&quot;</span>
            <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
          <span class="p">{</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                      <span class="s2">&quot;which parameterisations to apply the constraint to. If&quot;</span>
                      <span class="s2">&quot;an identified parameterisation affects multiple&quot;</span>
                      <span class="s2">&quot;experiments then the index of any one of those&quot;</span>
                      <span class="s2">&quot;experiments suffices to identify that parameterisation.&quot;</span>
                      <span class="s2">&quot;If None (the default) then constraints will be applied&quot;</span>
                      <span class="s2">&quot;to all parameterisations of this type.&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Identify which parameter of each parameterisation to&quot;</span>
                      <span class="s2">&quot;constrain by a (partial) parameter name to match. Model&quot;</span>
                      <span class="s2">&quot;name prefixes such as &#39;Detector1&#39; will be ignored as&quot;</span>
                      <span class="s2">&quot;parameterisations are already identified by experiment&quot;</span>
                      <span class="s2">&quot;id&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
          <span class="p">}</span>
          <span class="n">force_static</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Force a static parameterisation for the crystal&quot;</span>
                    <span class="s2">&quot;orientation when doing scan-varying refinement&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="n">smoother</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options that affect scan-varying parameterisation&quot;</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="p">{</span>
            <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="mf">36.0</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of scan between checkpoints in degrees. Can be&quot;</span>
                      <span class="s2">&quot;set to Auto.&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">absolute_num_intervals</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of intervals between checkpoints if scan_varying&quot;</span>
                      <span class="s2">&quot;refinement is requested. If set, this overrides&quot;</span>
                      <span class="s2">&quot;interval_width_degrees&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">detector</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;detector parameters&quot;</span>
      <span class="p">{</span>
        <span class="n">panels</span> <span class="o">=</span> <span class="o">*</span><span class="n">automatic</span> <span class="n">single</span> <span class="n">multiple</span> <span class="n">hierarchical</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select appropriate detector parameterisation. Both the&quot;</span>
                  <span class="s2">&quot;single and multiple panel detector options treat the whole&quot;</span>
                  <span class="s2">&quot;detector as a rigid body. The hierarchical parameterisation&quot;</span>
                  <span class="s2">&quot;treats groups of panels as separate rigid bodies.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">hierarchy_level</span> <span class="o">=</span> <span class="mi">0</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Level of the detector hierarchy (starting from the root at&quot;</span>
                  <span class="s2">&quot;0) at which to determine panel groups to parameterise&quot;</span>
                  <span class="s2">&quot;independently&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="o">*</span><span class="nb">all</span> <span class="n">position</span> <span class="n">orientation</span> <span class="n">distance</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix detector parameters. The translational parameters&quot;</span>
                  <span class="s2">&quot;(position) may be set separately to the orientation.&quot;</span>
          <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Fix detector parameters&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="n">fix_list</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix specified parameters by a list of 0-based indices or&quot;</span>
                  <span class="s2">&quot;partial names to match&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">constraints</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameter equal shift constraints to use in refinement.&quot;</span>
          <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="p">{</span>
          <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                    <span class="s2">&quot;which parameterisations to apply the constraint to. If an&quot;</span>
                    <span class="s2">&quot;identified parameterisation affects multiple experiments&quot;</span>
                    <span class="s2">&quot;then the index of any one of those experiments suffices&quot;</span>
                    <span class="s2">&quot;to identify that parameterisation. If None (the default)&quot;</span>
                    <span class="s2">&quot;then constraints will be applied to all parameterisations&quot;</span>
                    <span class="s2">&quot;of this type.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
          <span class="n">parameter</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Identify which parameter of each parameterisation to&quot;</span>
                    <span class="s2">&quot;constrain by a (partial) parameter name to match. Model&quot;</span>
                    <span class="s2">&quot;name prefixes such as &#39;Detector1&#39; will be ignored as&quot;</span>
                    <span class="s2">&quot;parameterisations are already identified by experiment id&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="p">}</span>
        <span class="n">force_static</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Force a static parameterisation for the detector when doing&quot;</span>
                  <span class="s2">&quot;scan-varying refinement&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">smoother</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options that affect scan-varying parameterisation&quot;</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="mf">36.0</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of scan between checkpoints in degrees. Can be set&quot;</span>
                    <span class="s2">&quot;to Auto.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">absolute_num_intervals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of intervals between checkpoints if scan_varying&quot;</span>
                    <span class="s2">&quot;refinement is requested. If set, this overrides&quot;</span>
                    <span class="s2">&quot;interval_width_degrees&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">goniometer</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;goniometer setting matrix parameters&quot;</span>
      <span class="p">{</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="o">*</span><span class="nb">all</span> <span class="n">in_beam_plane</span> <span class="n">out_beam_plane</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Whether to fix goniometer parameters. By default, fix all.&quot;</span>
                  <span class="s2">&quot;Alternatively the setting matrix can be constrained to&quot;</span>
                  <span class="s2">&quot;allow rotation only within the spindle-beam plane or to&quot;</span>
                  <span class="s2">&quot;allow rotation only around an axis that lies in that plane.&quot;</span>
                  <span class="s2">&quot;Set to None to refine the in two orthogonal directions.&quot;</span>
          <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Fix goniometer parameters&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span><span class="p">(</span><span class="n">multi</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fix_list</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix specified parameters by a list of 0-based indices or&quot;</span>
                  <span class="s2">&quot;partial names to match&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">constraints</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameter equal shift constraints to use in refinement.&quot;</span>
          <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="p">{</span>
          <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                    <span class="s2">&quot;which parameterisations to apply the constraint to. If an&quot;</span>
                    <span class="s2">&quot;identified parameterisation affects multiple experiments&quot;</span>
                    <span class="s2">&quot;then the index of any one of those experiments suffices&quot;</span>
                    <span class="s2">&quot;to identify that parameterisation. If None (the default)&quot;</span>
                    <span class="s2">&quot;then constraints will be applied to all parameterisations&quot;</span>
                    <span class="s2">&quot;of this type.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
          <span class="n">parameter</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Identify which parameter of each parameterisation to&quot;</span>
                    <span class="s2">&quot;constrain by a (partial) parameter name to match. Model&quot;</span>
                    <span class="s2">&quot;name prefixes such as &#39;Detector1&#39; will be ignored as&quot;</span>
                    <span class="s2">&quot;parameterisations are already identified by experiment id&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="p">}</span>
        <span class="n">force_static</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Force a static parameterisation for the goniometer when&quot;</span>
                  <span class="s2">&quot;doing scan-varying refinement&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">smoother</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options that affect scan-varying parameterisation&quot;</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="mf">36.0</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of scan between checkpoints in degrees. Can be set&quot;</span>
                    <span class="s2">&quot;to Auto.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">absolute_num_intervals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of intervals between checkpoints if scan_varying&quot;</span>
                    <span class="s2">&quot;refinement is requested. If set, this overrides&quot;</span>
                    <span class="s2">&quot;interval_width_degrees&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">sparse</span> <span class="o">=</span> <span class="n">Auto</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Calculate gradients using sparse data structures.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">treat_single_image_as_still</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Set this to True to treat a single image scan with a non zero&quot;</span>
                <span class="s2">&quot;oscillation width as a still&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">spherical_relp_model</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;For stills refinement, set true to use the spherical relp&quot;</span>
                <span class="s2">&quot;model for prediction and gradients.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="n">refinery</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters to configure the refinery&quot;</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">engine</span> <span class="o">=</span> <span class="n">SimpleLBFGS</span> <span class="n">LBFGScurvs</span> <span class="n">GaussNewton</span> <span class="o">*</span><span class="n">LevMar</span> <span class="n">SparseLevMar</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The minimisation engine to use&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="n">max_iterations</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of iterations in refinement before&quot;</span>
                <span class="s2">&quot;termination. None implies the engine supplies its own&quot;</span>
                <span class="s2">&quot;default.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">log</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Filename for an optional log that a minimisation engine may&quot;</span>
                <span class="s2">&quot;use to write additional information&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">path</span>
      <span class="n">journal</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Extra items to track in the refinement history&quot;</span>
      <span class="p">{</span>
        <span class="n">track_step</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record parameter shifts history in the refinement journal,&quot;</span>
                  <span class="s2">&quot;if the engine supports it.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="n">track_gradient</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record parameter gradients history in the refinement&quot;</span>
                  <span class="s2">&quot;journal, if the engine supports it.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="n">track_parameter_correlation</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record correlation matrix between columns of the Jacobian&quot;</span>
                  <span class="s2">&quot;for each step of refinement.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="n">track_jacobian_structure</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record numbers of explicit and structural zeroes in each&quot;</span>
                  <span class="s2">&quot;column of the Jacobian at each step of refinement.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="n">track_condition_number</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record condition number of the Jacobian for each step of &quot;</span>
                  <span class="s2">&quot;refinement.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="n">track_normal_matrix</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record the full normal matrix at each step of refinement&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="n">track_out_of_sample_rmsd</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record RMSDs calculated using the refined experiments with&quot;</span>
                  <span class="s2">&quot;reflections not used in refinement at each step. Only valid&quot;</span>
                  <span class="s2">&quot;if a subset of input reflections was taken for refinement&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">target</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters to configure the target function&quot;</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">rmsd_cutoff</span> <span class="o">=</span> <span class="o">*</span><span class="n">fraction_of_bin_size</span> <span class="n">absolute</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Method to choose rmsd cutoffs. This is currently either as a&quot;</span>
                <span class="s2">&quot;fraction of the discrete units of the spot positional data,&quot;</span>
                <span class="s2">&quot;i.e. (pixel width, pixel height, image thickness in phi), or&quot;</span>
                <span class="s2">&quot;a tuple of absolute values to use as the cutoffs&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="n">bin_size_fraction</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Set this to a fractional value, say 0.2, to make a cut off in&quot;</span>
                <span class="s2">&quot;the natural discrete units of positional data, viz., (pixel&quot;</span>
                <span class="s2">&quot;width, pixel height, image thickness in phi). This would then&quot;</span>
                <span class="s2">&quot;determine when the RMSD target is achieved. Only used if&quot;</span>
                <span class="s2">&quot;rmsd_cutoff = fraction_of_bin_size.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">absolute_cutoffs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Absolute Values for the RMSD target achieved cutoffs in X, Y&quot;</span>
                <span class="s2">&quot;and Phi. The units are (mm, mm, rad).&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
      <span class="n">gradient_calculation_blocksize</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of reflections to use for gradient&quot;</span>
                <span class="s2">&quot;calculation. If there are more reflections than this in the&quot;</span>
                <span class="s2">&quot;manager then the minimiser must do the full calculation in&quot;</span>
                <span class="s2">&quot;blocks.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">reflections</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters used by the reflection manager&quot;</span>
    <span class="p">{</span>
      <span class="n">reflections_per_degree</span> <span class="o">=</span> <span class="n">Auto</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The number of centroids per degree of the sequence to use in&quot;</span>
                <span class="s2">&quot;refinement. The default (Auto) uses all reflections unless&quot;</span>
                <span class="s2">&quot;the dataset is wider than a single turn. Then the number of&quot;</span>
                <span class="s2">&quot;reflections may be reduced until a minimum of 100 per degree&quot;</span>
                <span class="s2">&quot;of the sequence is reached to speed up calculations. Set this&quot;</span>
                <span class="s2">&quot;to None to force use all of suitable reflections.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">minimum_sample_size</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;cutoff that determines whether subsetting of the input&quot;</span>
                <span class="s2">&quot;reflection list is done&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">maximum_sample_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The maximum number of reflections to use in refinement.&quot;</span>
                <span class="s2">&quot;Overrides reflections_per_degree if that produces a larger&quot;</span>
                <span class="s2">&quot;sample size.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">random_seed</span> <span class="o">=</span> <span class="mi">42</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Random seed to use when sampling to create a working set of&quot;</span>
                <span class="s2">&quot;reflections. May be int or None.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">close_to_spindle_cutoff</span> <span class="o">=</span> <span class="mf">0.02</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The inclusion criterion currently uses the volume of the&quot;</span>
                <span class="s2">&quot;parallelepiped formed by the spindle axis, the incident beam&quot;</span>
                <span class="s2">&quot;and the scattered beam. If this is lower than some value then&quot;</span>
                <span class="s2">&quot;the reflection is excluded from refinement. In detector&quot;</span>
                <span class="s2">&quot;space, these are the reflections located close to the&quot;</span>
                <span class="s2">&quot;rotation axis.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">scan_margin</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Reflections within this value in degrees from the centre of&quot;</span>
                <span class="s2">&quot;the first or last image of the scan will be removed before&quot;</span>
                <span class="s2">&quot;refinement, unless doing so would result in too few remaining&quot;</span>
                <span class="s2">&quot;reflections. Reflections that are truncated at the scan edges&quot;</span>
                <span class="s2">&quot;have poorly-determined centroids and can bias the refined&quot;</span>
                <span class="s2">&quot;model if they are included.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">weighting_strategy</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters to configure weighting strategy overrides&quot;</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">{</span>
        <span class="n">override</span> <span class="o">=</span> <span class="n">statistical</span> <span class="n">stills</span> <span class="n">constant</span> <span class="n">external_deltapsi</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;selection of a strategy to override default weighting&quot;</span>
                  <span class="s2">&quot;behaviour&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="n">delpsi_constant</span> <span class="o">=</span> <span class="mi">1000000</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;used by the stills strategy to choose absolute weight value&quot;</span>
                  <span class="s2">&quot;for the angular distance from Ewald sphere term of the&quot;</span>
                  <span class="s2">&quot;target function, whilst the X and Y parts use statistical&quot;</span>
                  <span class="s2">&quot;weights&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">constants</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="mf">1.0</span> <span class="mf">1.0</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;constant weights for three parts of the target function,&quot;</span>
                  <span class="s2">&quot;whether the case is for stills or scans. The default gives&quot;</span>
                  <span class="s2">&quot;unit weighting.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">wavelength_weight</span> <span class="o">=</span> <span class="mf">1e4</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Weight for the wavelength term in the target function for&quot;</span>
                  <span class="s2">&quot;Laue refinement&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="n">outlier</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Outlier rejection after initial reflection prediction.&quot;</span>
      <span class="p">{</span>
        <span class="n">algorithm</span> <span class="o">=</span> <span class="n">null</span> <span class="n">auto</span> <span class="n">mcd</span> <span class="o">*</span><span class="n">tukey</span> <span class="n">sauter_poon</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Outlier rejection algorithm. If auto is selected, the&quot;</span>
                  <span class="s2">&quot;algorithm is chosen automatically.&quot;</span>
          <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Outlier rejection algorithm&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of processes over which to split outlier&quot;</span>
                  <span class="s2">&quot;identification. If set to Auto, DIALS will choose&quot;</span>
                  <span class="s2">&quot;automatically.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">minimum_number_of_reflections</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The minimum number of input observations per outlier&quot;</span>
                  <span class="s2">&quot;rejection job below which all reflections in the job will&quot;</span>
                  <span class="s2">&quot;be rejected as potential outliers.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">separate_experiments</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If true, outlier rejection will be performed on each&quot;</span>
                  <span class="s2">&quot;experiment separately. Otherwise, the data from all&quot;</span>
                  <span class="s2">&quot;experiments will be combined for outlier rejection.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">separate_panels</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Perform outlier rejection separately for each panel of a&quot;</span>
                  <span class="s2">&quot;multi- panel detector model. Otherwise data from across all&quot;</span>
                  <span class="s2">&quot;panels will be combined for outlier rejection.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">separate_blocks</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If true, for scans outlier rejection will be performed&quot;</span>
                  <span class="s2">&quot;separately in equal-width blocks of phi, controlled by the&quot;</span>
                  <span class="s2">&quot;parameter outlier.block_width.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">block_width</span> <span class="o">=</span> <span class="n">Auto</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If separate_blocks, a scan will be divided into equal-sized&quot;</span>
                  <span class="s2">&quot;blocks with width (in degrees) close to this value for&quot;</span>
                  <span class="s2">&quot;outlier rejection. If Auto, a width of at least 18 degrees&quot;</span>
                  <span class="s2">&quot;will be determined, such that each block contains enough&quot;</span>
                  <span class="s2">&quot;reflections to perform outlier rejection.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">separate_images</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If true, every image will be treated separately for outlier&quot;</span>
                  <span class="s2">&quot;rejection. It is a special case that will override both&quot;</span>
                  <span class="s2">&quot;separate_experiments and separate_blocks, and will set&quot;</span>
                  <span class="s2">&quot;these to False if required.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">tukey</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options for the tukey outlier rejector&quot;</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">iqr_multiplier</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The IQR multiplier used to detect outliers. A value of&quot;</span>
                    <span class="s2">&quot;1.5 gives Tukey&#39;s rule for outlier detection&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">mcd</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options for the mcd outlier rejector, which uses an&quot;</span>
                  <span class="s2">&quot;algorithm based on FAST-MCD by Rousseeuw and van Driessen.&quot;</span>
                  <span class="s2">&quot;See doi.org/10.1080/00401706.1999.10485670.&quot;</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Decimal fraction controlling the size of subsets over&quot;</span>
                    <span class="s2">&quot;which the covariance matrix determinant is minimised.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">max_n_groups</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The maximum number of groups to split the dataset into if&quot;</span>
                    <span class="s2">&quot;the dataset is &#39;large&#39; (more observations than twice the&quot;</span>
                    <span class="s2">&quot;min_group_size).&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">min_group_size</span> <span class="o">=</span> <span class="mi">300</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The smallest sub-dataset size when splitting the dataset&quot;</span>
                    <span class="s2">&quot;into a number of groups, maximally max_n_groups.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">n_trials</span> <span class="o">=</span> <span class="mi">500</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The number of samples used for initial estimates to seed&quot;</span>
                    <span class="s2">&quot;the search within each sub-dataset.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The number of concentration steps to take after initial&quot;</span>
                    <span class="s2">&quot;estimates.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If the dataset is &#39;large&#39;, the number of concentration&quot;</span>
                    <span class="s2">&quot;steps to take after applying the best subset estimates to&quot;</span>
                    <span class="s2">&quot;the merged group.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">k3</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If the dataset is &#39;small&#39;, the number of concentration&quot;</span>
                    <span class="s2">&quot;steps to take after selecting the best of the initial&quot;</span>
                    <span class="s2">&quot;estimates, applied to the whole dataset.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">threshold_probability</span> <span class="o">=</span> <span class="mf">0.975</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Quantile probability from the Chi-squared distribution&quot;</span>
                    <span class="s2">&quot;with number of degrees of freedom equal to the number of&quot;</span>
                    <span class="s2">&quot;dimensions of the data data (e.g. 3 for X, Y and Phi&quot;</span>
                    <span class="s2">&quot;residuals). Observations whose robust Mahalanobis&quot;</span>
                    <span class="s2">&quot;distances are larger than the obtained quantile will be&quot;</span>
                    <span class="s2">&quot;flagged as outliers.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">sauter_poon</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options for the outlier rejector described in Sauter &amp; Poon&quot;</span>
                  <span class="s2">&quot;(2010) (https://doi.org/10.1107/S0021889810010782)&quot;</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">px_sz</span> <span class="o">=</span> <span class="n">Auto</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;X, Y pixel size in mm. If Auto, this will be taken from&quot;</span>
                    <span class="s2">&quot;the first panel of the first experiment.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">value_min</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>
          <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Verbose output.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
            <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="n">pdf</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Output file name for making graphs of |dr| vs spot number&quot;</span>
                    <span class="s2">&quot;and dy vs dx.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
            <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">output</span> <span class="p">{</span>
    <span class="n">experiments</span> <span class="o">=</span> <span class="n">indexed</span><span class="o">.</span><span class="n">expt</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">path</span>
    <span class="n">reflections</span> <span class="o">=</span> <span class="n">indexed</span><span class="o">.</span><span class="n">refl</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">path</span>
    <span class="n">log</span> <span class="o">=</span> <span class="n">dials</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">log</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">refiner</span> <span class="p">{</span>
  <span class="n">output</span> <span class="p">{</span>
    <span class="n">experiments</span> <span class="o">=</span> <span class="n">refined</span><span class="o">.</span><span class="n">expt</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The filename for refined experimental models&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
    <span class="n">reflections</span> <span class="o">=</span> <span class="n">refined</span><span class="o">.</span><span class="n">refl</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The filename for reflections with updated predictions&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
    <span class="n">include_unused_reflections</span> <span class="o">=</span> <span class="kc">True</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If True, keep reflections unused in refinement in updated&quot;</span>
              <span class="s2">&quot;reflections file. Otherwise, remove them&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The filename for output of the reflection table for reflections&quot;</span>
              <span class="s2">&quot;used in refinement, containing extra columns used internally.&quot;</span>
              <span class="s2">&quot;Intended for debugging purposes only&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">centroids</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The filename for the table of centroids at the end of&quot;</span>
              <span class="s2">&quot;refinement&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">parameter_table</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The filename for the table of scan varying parameter values&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">log</span> <span class="o">=</span> <span class="n">dials</span><span class="o">.</span><span class="n">refine</span><span class="o">.</span><span class="n">log</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
    <span class="n">correlation_plot</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">filename</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The base filename for output of plots of parameter&quot;</span>
                <span class="s2">&quot;correlations. A file extension may be added to control the&quot;</span>
                <span class="s2">&quot;type of output file, if it is one of matplotlib&#39;s supported&quot;</span>
                <span class="s2">&quot;types. A JSON file with the same base filename will also be&quot;</span>
                <span class="s2">&quot;created, containing the correlation matrix and column labels&quot;</span>
                <span class="s2">&quot;for later inspection, replotting etc.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
      <span class="n">col_select</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Specific columns to include in the plots of parameter&quot;</span>
                <span class="s2">&quot;correlations, either specified by parameter name or 0-based&quot;</span>
                <span class="s2">&quot;column index. Defaults to all columns. This option is useful&quot;</span>
                <span class="s2">&quot;when there is a large number of parameters&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
      <span class="n">steps</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Steps for which to make correlation plots. By default only&quot;</span>
                <span class="s2">&quot;the final step is plotted. Uses zero-based numbering, so the&quot;</span>
                <span class="s2">&quot;first step is numbered 0.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">history</span> <span class="o">=</span> <span class="kc">None</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The filename for output of the refinement history json&quot;</span>
      <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="n">n_static_macrocycles</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of macro-cycles of static refinement to perform&quot;</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="n">separate_independent_sets</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If true, the experiment list will be separated into independent&quot;</span>
            <span class="s2">&quot;groups that do not share models, and these groups will be refined&quot;</span>
            <span class="s2">&quot;separately.&quot;</span>
    <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
  <span class="n">refinement</span>
    <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters to configure the refinement&quot;</span>
  <span class="p">{</span>
    <span class="n">mp</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="p">{</span>
      <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The number of processes to use. Not all choices of refinement&quot;</span>
                <span class="s2">&quot;engine support nproc &gt; 1. Where multiprocessing is possible,&quot;</span>
                <span class="s2">&quot;it is helpful only in certain circumstances, so this is not&quot;</span>
                <span class="s2">&quot;recommended for typical use.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">parameterisation</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters to control the parameterisation of experimental&quot;</span>
              <span class="s2">&quot;models&quot;</span>
    <span class="p">{</span>
      <span class="n">auto_reduction</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;determine behaviour when there are too few reflections to&quot;</span>
                <span class="s2">&quot;reasonably produce a full parameterisation of the experiment&quot;</span>
                <span class="s2">&quot;list&quot;</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">{</span>
        <span class="n">min_nref_per_parameter</span> <span class="o">=</span> <span class="mi">5</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;the smallest number of reflections per parameter for a&quot;</span>
                  <span class="s2">&quot;model parameterisation below which the parameterisation&quot;</span>
                  <span class="s2">&quot;will not be made in full, but the action described below&quot;</span>
                  <span class="s2">&quot;will be triggered.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">action</span> <span class="o">=</span> <span class="o">*</span><span class="n">fail</span> <span class="n">fix</span> <span class="n">remove</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;action to take if there are too few reflections across the&quot;</span>
                  <span class="s2">&quot;experiments related to a particular model parameterisation.&quot;</span>
                  <span class="s2">&quot;If fail, an exception will be raised and refinement will&quot;</span>
                  <span class="s2">&quot;not proceed. If fix, refinement will continue but with the&quot;</span>
                  <span class="s2">&quot;parameters relating to that model remaining fixed at their&quot;</span>
                  <span class="s2">&quot;initial values. If remove, parameters relating to that&quot;</span>
                  <span class="s2">&quot;model will be fixed, and in addition all reflections&quot;</span>
                  <span class="s2">&quot;related to that parameterisation will be removed. This will&quot;</span>
                  <span class="s2">&quot;therefore remove these reflections from other&quot;</span>
                  <span class="s2">&quot;parameterisations of the global model too. For example, if&quot;</span>
                  <span class="s2">&quot;a crystal model could not be parameterised it will be&quot;</span>
                  <span class="s2">&quot;excised completely and not contribute to the joint&quot;</span>
                  <span class="s2">&quot;refinement of the detector and beam. In the fix mode,&quot;</span>
                  <span class="s2">&quot;reflections emanating from that crystal will still form&quot;</span>
                  <span class="s2">&quot;residuals and will contribute to detector and beam&quot;</span>
                  <span class="s2">&quot;refinement.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="p">}</span>
      <span class="n">scan_varying</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Allow models that are not forced to be static to vary during&quot;</span>
                <span class="s2">&quot;the scan, Auto will run one macrocycle with static then scan&quot;</span>
                <span class="s2">&quot;varying refinement for the crystal&quot;</span>
        <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Scan-varying refinement&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Overall default value of the width of scan between&quot;</span>
                <span class="s2">&quot;checkpoints in degrees for scan-varying refinement. If set to&quot;</span>
                <span class="s2">&quot;None, each model will use its own specified value.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">compose_model_per</span> <span class="o">=</span> <span class="n">image</span> <span class="o">*</span><span class="n">block</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;For scan-varying parameterisations, compose a new model&quot;</span>
                <span class="s2">&quot;either every image or within blocks of a width specified in&quot;</span>
                <span class="s2">&quot;the reflections parameters. When this block width is larger&quot;</span>
                <span class="s2">&quot;than the image width the result is faster, with a trade-off&quot;</span>
                <span class="s2">&quot;in accuracy&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">block_width</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of a reflection &#39;block&#39; (in degrees) determining how&quot;</span>
                <span class="s2">&quot;fine- grained the model used for scan-varying prediction&quot;</span>
                <span class="s2">&quot;during refinement is. Currently only has any effect if the&quot;</span>
                <span class="s2">&quot;crystal parameterisation is set to use&quot;</span>
                <span class="s2">&quot;compose_model_per=block&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">set_scan_varying_errors</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If scan-varying refinement is done, and if the estimated&quot;</span>
                <span class="s2">&quot;covariance of the model states have been calculated by the&quot;</span>
                <span class="s2">&quot;minimiser, choose whether to return this to the models or&quot;</span>
                <span class="s2">&quot;not. The default is not to, in order to keep the file size of&quot;</span>
                <span class="s2">&quot;the serialized model small. At the moment, this only has an&quot;</span>
                <span class="s2">&quot;effect for crystal unit cell (B matrix) errors.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="n">trim_scan_to_observations</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;For scan-varying refinement, trim scan objects to the range&quot;</span>
                <span class="s2">&quot;of observed reflections. This avoids failures in refinement&quot;</span>
                <span class="s2">&quot;for cases where the extremes of scans contain no data, such&quot;</span>
                <span class="s2">&quot;as when the crystal moves out of the beam.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">debug_centroid_analysis</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Set True to write out a file containing the reflections used&quot;</span>
                <span class="s2">&quot;for centroid analysis for automatic setting of the &quot;</span>
                <span class="s2">&quot;scan-varying interval width. This can then be analysed with&quot;</span>
                <span class="s2">&quot;dev.dials.plot_centroid_analysis (requires dials_scratch&quot;</span>
                <span class="s2">&quot;repository).&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
      <span class="n">beam</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;beam parameters&quot;</span>
      <span class="p">{</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="o">*</span><span class="nb">all</span> <span class="n">in_spindle_plane</span> <span class="n">out_spindle_plane</span> <span class="n">wavelength</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Whether to fix beam parameters. By default,&quot;</span>
                  <span class="s2">&quot;in_spindle_plane is selected, and one of the two parameters&quot;</span>
                  <span class="s2">&quot;is fixed. If a goniometer is present this leads to the beam&quot;</span>
                  <span class="s2">&quot;orientation being restricted to a direction in the initial&quot;</span>
                  <span class="s2">&quot;spindle-beam plane. Wavelength is also fixed by default, to&quot;</span>
                  <span class="s2">&quot;allow refinement of the unit cell volume.&quot;</span>
          <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Fix beam parameters&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span><span class="p">(</span><span class="n">multi</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fix_list</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix specified parameters by a list of 0-based indices or&quot;</span>
                  <span class="s2">&quot;partial names to match&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">constraints</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameter equal shift constraints to use in refinement.&quot;</span>
          <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="p">{</span>
          <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                    <span class="s2">&quot;which parameterisations to apply the constraint to. If an&quot;</span>
                    <span class="s2">&quot;identified parameterisation affects multiple experiments&quot;</span>
                    <span class="s2">&quot;then the index of any one of those experiments suffices&quot;</span>
                    <span class="s2">&quot;to identify that parameterisation. If None (the default)&quot;</span>
                    <span class="s2">&quot;then constraints will be applied to all parameterisations&quot;</span>
                    <span class="s2">&quot;of this type.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
          <span class="n">parameter</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Identify which parameter of each parameterisation to&quot;</span>
                    <span class="s2">&quot;constrain by a (partial) parameter name to match. Model&quot;</span>
                    <span class="s2">&quot;name prefixes such as &#39;Detector1&#39; will be ignored as&quot;</span>
                    <span class="s2">&quot;parameterisations are already identified by experiment id&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="p">}</span>
        <span class="n">force_static</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Force a static parameterisation for the beam when doing&quot;</span>
                  <span class="s2">&quot;scan-varying refinement&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">smoother</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options that affect scan-varying parameterisation&quot;</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="mf">36.0</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of scan between checkpoints in degrees. Can be set&quot;</span>
                    <span class="s2">&quot;to Auto.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">absolute_num_intervals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of intervals between checkpoints if scan_varying&quot;</span>
                    <span class="s2">&quot;refinement is requested. If set, this overrides&quot;</span>
                    <span class="s2">&quot;interval_width_degrees&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">crystal</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;crystal parameters&quot;</span>
      <span class="p">{</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="nb">all</span> <span class="o">*</span><span class="n">cell</span> <span class="n">orientation</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix crystal parameters&quot;</span>
          <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Fix crystal parameters&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="n">unit_cell</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">fix_list</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix specified parameters by a list of 0-based indices or&quot;</span>
                    <span class="s2">&quot;partial names to match&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="n">restraints</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Least squares unit cell restraints to use in refinement.&quot;</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="p">{</span>
            <span class="n">tie_to_target</span>
              <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="p">{</span>
              <span class="n">values</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Target unit cell parameters for the restraint for&quot;</span>
                        <span class="s2">&quot;this parameterisation&quot;</span>
                <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
              <span class="n">sigmas</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The unit cell target values are associated with&quot;</span>
                        <span class="s2">&quot;sigmas which are used to determine the weight of each&quot;</span>
                        <span class="s2">&quot;restraint. A sigma of zero will remove the restraint&quot;</span>
                        <span class="s2">&quot;at that position. If symmetry constrains two cell&quot;</span>
                        <span class="s2">&quot;dimensions to be equal then only the smaller of the&quot;</span>
                        <span class="s2">&quot;two sigmas will be kept&quot;</span>
                <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
              <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                        <span class="s2">&quot;which parameterisations to apply these restraints to.&quot;</span>
                        <span class="s2">&quot;If an identified parameterisation affects multiple&quot;</span>
                        <span class="s2">&quot;experiments then the index of any one of those&quot;</span>
                        <span class="s2">&quot;experiments suffices to restrain that&quot;</span>
                        <span class="s2">&quot;parameterisation. If None (the default) then the&quot;</span>
                        <span class="s2">&quot;restraints will be applied to all experiments.&quot;</span>
                <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="n">tie_to_group</span>
              <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="p">{</span>
              <span class="n">target</span> <span class="o">=</span> <span class="o">*</span><span class="n">mean</span> <span class="n">low_memory_mean</span> <span class="n">median</span>
                <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Function to tie group parameter values to&quot;</span>
                <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
              <span class="n">sigmas</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The unit cell parameters are associated with sigmas&quot;</span>
                        <span class="s2">&quot;which are used to determine the weight of each&quot;</span>
                        <span class="s2">&quot;restraint. A sigma of zero will remove the restraint&quot;</span>
                        <span class="s2">&quot;at that position.&quot;</span>
                <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
              <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                        <span class="s2">&quot;which  parameterisations to apply these restraints&quot;</span>
                        <span class="s2">&quot;to. For every parameterisation that requires a&quot;</span>
                        <span class="s2">&quot;restraint at least one experiment index must be&quot;</span>
                        <span class="s2">&quot;supplied. If None (the default) the restraints will&quot;</span>
                        <span class="s2">&quot;be applied to all experiments.&quot;</span>
                <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">}</span>
          <span class="p">}</span>
          <span class="n">constraints</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameter equal shift constraints to use in refinement.&quot;</span>
            <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
          <span class="p">{</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                      <span class="s2">&quot;which parameterisations to apply the constraint to. If&quot;</span>
                      <span class="s2">&quot;an identified parameterisation affects multiple&quot;</span>
                      <span class="s2">&quot;experiments then the index of any one of those&quot;</span>
                      <span class="s2">&quot;experiments suffices to identify that parameterisation.&quot;</span>
                      <span class="s2">&quot;If None (the default) then constraints will be applied&quot;</span>
                      <span class="s2">&quot;to all parameterisations of this type.&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Identify which parameter of each parameterisation to&quot;</span>
                      <span class="s2">&quot;constrain by a (partial) parameter name to match. Model&quot;</span>
                      <span class="s2">&quot;name prefixes such as &#39;Detector1&#39; will be ignored as&quot;</span>
                      <span class="s2">&quot;parameterisations are already identified by experiment&quot;</span>
                      <span class="s2">&quot;id&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
          <span class="p">}</span>
          <span class="n">force_static</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Force a static parameterisation for the crystal unit cell&quot;</span>
                    <span class="s2">&quot;when doing scan-varying refinement&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="n">smoother</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options that affect scan-varying parameterisation&quot;</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="p">{</span>
            <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="mf">36.0</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of scan between checkpoints in degrees. Can be&quot;</span>
                      <span class="s2">&quot;set to Auto.&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">absolute_num_intervals</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of intervals between checkpoints if scan_varying&quot;</span>
                      <span class="s2">&quot;refinement is requested. If set, this overrides&quot;</span>
                      <span class="s2">&quot;interval_width_degrees&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">orientation</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">fix_list</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix specified parameters by a list of 0-based indices or&quot;</span>
                    <span class="s2">&quot;partial names to match&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="n">constraints</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameter equal shift constraints to use in refinement.&quot;</span>
            <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
          <span class="p">{</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                      <span class="s2">&quot;which parameterisations to apply the constraint to. If&quot;</span>
                      <span class="s2">&quot;an identified parameterisation affects multiple&quot;</span>
                      <span class="s2">&quot;experiments then the index of any one of those&quot;</span>
                      <span class="s2">&quot;experiments suffices to identify that parameterisation.&quot;</span>
                      <span class="s2">&quot;If None (the default) then constraints will be applied&quot;</span>
                      <span class="s2">&quot;to all parameterisations of this type.&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Identify which parameter of each parameterisation to&quot;</span>
                      <span class="s2">&quot;constrain by a (partial) parameter name to match. Model&quot;</span>
                      <span class="s2">&quot;name prefixes such as &#39;Detector1&#39; will be ignored as&quot;</span>
                      <span class="s2">&quot;parameterisations are already identified by experiment&quot;</span>
                      <span class="s2">&quot;id&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
          <span class="p">}</span>
          <span class="n">force_static</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Force a static parameterisation for the crystal&quot;</span>
                    <span class="s2">&quot;orientation when doing scan-varying refinement&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="n">smoother</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options that affect scan-varying parameterisation&quot;</span>
            <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="p">{</span>
            <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="mf">36.0</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of scan between checkpoints in degrees. Can be&quot;</span>
                      <span class="s2">&quot;set to Auto.&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">absolute_num_intervals</span> <span class="o">=</span> <span class="kc">None</span>
              <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of intervals between checkpoints if scan_varying&quot;</span>
                      <span class="s2">&quot;refinement is requested. If set, this overrides&quot;</span>
                      <span class="s2">&quot;interval_width_degrees&quot;</span>
              <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">detector</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;detector parameters&quot;</span>
      <span class="p">{</span>
        <span class="n">panels</span> <span class="o">=</span> <span class="o">*</span><span class="n">automatic</span> <span class="n">single</span> <span class="n">multiple</span> <span class="n">hierarchical</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select appropriate detector parameterisation. Both the&quot;</span>
                  <span class="s2">&quot;single and multiple panel detector options treat the whole&quot;</span>
                  <span class="s2">&quot;detector as a rigid body. The hierarchical parameterisation&quot;</span>
                  <span class="s2">&quot;treats groups of panels as separate rigid bodies.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">hierarchy_level</span> <span class="o">=</span> <span class="mi">0</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Level of the detector hierarchy (starting from the root at&quot;</span>
                  <span class="s2">&quot;0) at which to determine panel groups to parameterise&quot;</span>
                  <span class="s2">&quot;independently&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="nb">all</span> <span class="n">position</span> <span class="o">*</span><span class="n">orientation</span> <span class="n">distance</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix detector parameters. The translational parameters&quot;</span>
                  <span class="s2">&quot;(position) may be set separately to the orientation.&quot;</span>
          <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Fix detector parameters&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="n">fix_list</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix specified parameters by a list of 0-based indices or&quot;</span>
                  <span class="s2">&quot;partial names to match&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">constraints</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameter equal shift constraints to use in refinement.&quot;</span>
          <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="p">{</span>
          <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                    <span class="s2">&quot;which parameterisations to apply the constraint to. If an&quot;</span>
                    <span class="s2">&quot;identified parameterisation affects multiple experiments&quot;</span>
                    <span class="s2">&quot;then the index of any one of those experiments suffices&quot;</span>
                    <span class="s2">&quot;to identify that parameterisation. If None (the default)&quot;</span>
                    <span class="s2">&quot;then constraints will be applied to all parameterisations&quot;</span>
                    <span class="s2">&quot;of this type.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
          <span class="n">parameter</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Identify which parameter of each parameterisation to&quot;</span>
                    <span class="s2">&quot;constrain by a (partial) parameter name to match. Model&quot;</span>
                    <span class="s2">&quot;name prefixes such as &#39;Detector1&#39; will be ignored as&quot;</span>
                    <span class="s2">&quot;parameterisations are already identified by experiment id&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="p">}</span>
        <span class="n">force_static</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Force a static parameterisation for the detector when doing&quot;</span>
                  <span class="s2">&quot;scan-varying refinement&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">smoother</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options that affect scan-varying parameterisation&quot;</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="mf">36.0</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of scan between checkpoints in degrees. Can be set&quot;</span>
                    <span class="s2">&quot;to Auto.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">absolute_num_intervals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of intervals between checkpoints if scan_varying&quot;</span>
                    <span class="s2">&quot;refinement is requested. If set, this overrides&quot;</span>
                    <span class="s2">&quot;interval_width_degrees&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">goniometer</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;goniometer setting matrix parameters&quot;</span>
      <span class="p">{</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="nb">all</span> <span class="n">in_beam_plane</span> <span class="n">out_beam_plane</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Whether to fix goniometer parameters. By default, fix all.&quot;</span>
                  <span class="s2">&quot;Alternatively the setting matrix can be constrained to&quot;</span>
                  <span class="s2">&quot;allow rotation only within the spindle-beam plane or to&quot;</span>
                  <span class="s2">&quot;allow rotation only around an axis that lies in that plane.&quot;</span>
                  <span class="s2">&quot;Set to None to refine the in two orthogonal directions.&quot;</span>
          <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Fix goniometer parameters&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span><span class="p">(</span><span class="n">multi</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">fix_list</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Fix specified parameters by a list of 0-based indices or&quot;</span>
                  <span class="s2">&quot;partial names to match&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">strings</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">constraints</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameter equal shift constraints to use in refinement.&quot;</span>
          <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="p">{</span>
          <span class="nb">id</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Select only the specified experiments when looking up&quot;</span>
                    <span class="s2">&quot;which parameterisations to apply the constraint to. If an&quot;</span>
                    <span class="s2">&quot;identified parameterisation affects multiple experiments&quot;</span>
                    <span class="s2">&quot;then the index of any one of those experiments suffices&quot;</span>
                    <span class="s2">&quot;to identify that parameterisation. If None (the default)&quot;</span>
                    <span class="s2">&quot;then constraints will be applied to all parameterisations&quot;</span>
                    <span class="s2">&quot;of this type.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ints</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
          <span class="n">parameter</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Identify which parameter of each parameterisation to&quot;</span>
                    <span class="s2">&quot;constrain by a (partial) parameter name to match. Model&quot;</span>
                    <span class="s2">&quot;name prefixes such as &#39;Detector1&#39; will be ignored as&quot;</span>
                    <span class="s2">&quot;parameterisations are already identified by experiment id&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
        <span class="p">}</span>
        <span class="n">force_static</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Force a static parameterisation for the goniometer when&quot;</span>
                  <span class="s2">&quot;doing scan-varying refinement&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">smoother</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options that affect scan-varying parameterisation&quot;</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">interval_width_degrees</span> <span class="o">=</span> <span class="mf">36.0</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Width of scan between checkpoints in degrees. Can be set&quot;</span>
                    <span class="s2">&quot;to Auto.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">absolute_num_intervals</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of intervals between checkpoints if scan_varying&quot;</span>
                    <span class="s2">&quot;refinement is requested. If set, this overrides&quot;</span>
                    <span class="s2">&quot;interval_width_degrees&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">sparse</span> <span class="o">=</span> <span class="n">Auto</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Calculate gradients using sparse data structures.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">treat_single_image_as_still</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Set this to True to treat a single image scan with a non zero&quot;</span>
                <span class="s2">&quot;oscillation width as a still&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">spherical_relp_model</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;For stills refinement, set true to use the spherical relp&quot;</span>
                <span class="s2">&quot;model for prediction and gradients.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="n">refinery</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters to configure the refinery&quot;</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">engine</span> <span class="o">=</span> <span class="n">SimpleLBFGS</span> <span class="n">LBFGScurvs</span> <span class="n">GaussNewton</span> <span class="o">*</span><span class="n">LevMar</span> <span class="n">SparseLevMar</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The minimisation engine to use&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="n">max_iterations</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of iterations in refinement before&quot;</span>
                <span class="s2">&quot;termination. None implies the engine supplies its own&quot;</span>
                <span class="s2">&quot;default.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">log</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Filename for an optional log that a minimisation engine may&quot;</span>
                <span class="s2">&quot;use to write additional information&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">path</span>
      <span class="n">journal</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Extra items to track in the refinement history&quot;</span>
      <span class="p">{</span>
        <span class="n">track_step</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record parameter shifts history in the refinement journal,&quot;</span>
                  <span class="s2">&quot;if the engine supports it.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="n">track_gradient</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record parameter gradients history in the refinement&quot;</span>
                  <span class="s2">&quot;journal, if the engine supports it.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="n">track_parameter_correlation</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record correlation matrix between columns of the Jacobian&quot;</span>
                  <span class="s2">&quot;for each step of refinement.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="n">track_jacobian_structure</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record numbers of explicit and structural zeroes in each&quot;</span>
                  <span class="s2">&quot;column of the Jacobian at each step of refinement.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="n">track_condition_number</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record condition number of the Jacobian for each step of &quot;</span>
                  <span class="s2">&quot;refinement.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="n">track_normal_matrix</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record the full normal matrix at each step of refinement&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
        <span class="n">track_out_of_sample_rmsd</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Record RMSDs calculated using the refined experiments with&quot;</span>
                  <span class="s2">&quot;reflections not used in refinement at each step. Only valid&quot;</span>
                  <span class="s2">&quot;if a subset of input reflections was taken for refinement&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">target</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters to configure the target function&quot;</span>
      <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">{</span>
      <span class="n">rmsd_cutoff</span> <span class="o">=</span> <span class="o">*</span><span class="n">fraction_of_bin_size</span> <span class="n">absolute</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Method to choose rmsd cutoffs. This is currently either as a&quot;</span>
                <span class="s2">&quot;fraction of the discrete units of the spot positional data,&quot;</span>
                <span class="s2">&quot;i.e. (pixel width, pixel height, image thickness in phi), or&quot;</span>
                <span class="s2">&quot;a tuple of absolute values to use as the cutoffs&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
      <span class="n">bin_size_fraction</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Set this to a fractional value, say 0.2, to make a cut off in&quot;</span>
                <span class="s2">&quot;the natural discrete units of positional data, viz., (pixel&quot;</span>
                <span class="s2">&quot;width, pixel height, image thickness in phi). This would then&quot;</span>
                <span class="s2">&quot;determine when the RMSD target is achieved. Only used if&quot;</span>
                <span class="s2">&quot;rmsd_cutoff = fraction_of_bin_size.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">absolute_cutoffs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Absolute Values for the RMSD target achieved cutoffs in X, Y&quot;</span>
                <span class="s2">&quot;and Phi. The units are (mm, mm, rad).&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
      <span class="n">gradient_calculation_blocksize</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Maximum number of reflections to use for gradient&quot;</span>
                <span class="s2">&quot;calculation. If there are more reflections than this in the&quot;</span>
                <span class="s2">&quot;manager then the minimiser must do the full calculation in&quot;</span>
                <span class="s2">&quot;blocks.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">reflections</span>
      <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters used by the reflection manager&quot;</span>
    <span class="p">{</span>
      <span class="n">reflections_per_degree</span> <span class="o">=</span> <span class="n">Auto</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The number of centroids per degree of the sequence to use in&quot;</span>
                <span class="s2">&quot;refinement. The default (Auto) uses all reflections unless&quot;</span>
                <span class="s2">&quot;the dataset is wider than a single turn. Then the number of&quot;</span>
                <span class="s2">&quot;reflections may be reduced until a minimum of 100 per degree&quot;</span>
                <span class="s2">&quot;of the sequence is reached to speed up calculations. Set this&quot;</span>
                <span class="s2">&quot;to None to force use all of suitable reflections.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">minimum_sample_size</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;cutoff that determines whether subsetting of the input&quot;</span>
                <span class="s2">&quot;reflection list is done&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">maximum_sample_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The maximum number of reflections to use in refinement.&quot;</span>
                <span class="s2">&quot;Overrides reflections_per_degree if that produces a larger&quot;</span>
                <span class="s2">&quot;sample size.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">random_seed</span> <span class="o">=</span> <span class="mi">42</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Random seed to use when sampling to create a working set of&quot;</span>
                <span class="s2">&quot;reflections. May be int or None.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">close_to_spindle_cutoff</span> <span class="o">=</span> <span class="mf">0.02</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The inclusion criterion currently uses the volume of the&quot;</span>
                <span class="s2">&quot;parallelepiped formed by the spindle axis, the incident beam&quot;</span>
                <span class="s2">&quot;and the scattered beam. If this is lower than some value then&quot;</span>
                <span class="s2">&quot;the reflection is excluded from refinement. In detector&quot;</span>
                <span class="s2">&quot;space, these are the reflections located close to the&quot;</span>
                <span class="s2">&quot;rotation axis.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">scan_margin</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Reflections within this value in degrees from the centre of&quot;</span>
                <span class="s2">&quot;the first or last image of the scan will be removed before&quot;</span>
                <span class="s2">&quot;refinement, unless doing so would result in too few remaining&quot;</span>
                <span class="s2">&quot;reflections. Reflections that are truncated at the scan edges&quot;</span>
                <span class="s2">&quot;have poorly-determined centroids and can bias the refined&quot;</span>
                <span class="s2">&quot;model if they are included.&quot;</span>
        <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">weighting_strategy</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Parameters to configure weighting strategy overrides&quot;</span>
        <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="p">{</span>
        <span class="n">override</span> <span class="o">=</span> <span class="n">statistical</span> <span class="n">stills</span> <span class="n">constant</span> <span class="n">external_deltapsi</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;selection of a strategy to override default weighting&quot;</span>
                  <span class="s2">&quot;behaviour&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="n">delpsi_constant</span> <span class="o">=</span> <span class="mi">1000000</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;used by the stills strategy to choose absolute weight value&quot;</span>
                  <span class="s2">&quot;for the angular distance from Ewald sphere term of the&quot;</span>
                  <span class="s2">&quot;target function, whilst the X and Y parts use statistical&quot;</span>
                  <span class="s2">&quot;weights&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">constants</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="mf">1.0</span> <span class="mf">1.0</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;constant weights for three parts of the target function,&quot;</span>
                  <span class="s2">&quot;whether the case is for stills or scans. The default gives&quot;</span>
                  <span class="s2">&quot;unit weighting.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">wavelength_weight</span> <span class="o">=</span> <span class="mf">1e4</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Weight for the wavelength term in the target function for&quot;</span>
                  <span class="s2">&quot;Laue refinement&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="n">outlier</span>
        <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Outlier rejection after initial reflection prediction.&quot;</span>
      <span class="p">{</span>
        <span class="n">algorithm</span> <span class="o">=</span> <span class="n">null</span> <span class="n">auto</span> <span class="n">mcd</span> <span class="o">*</span><span class="n">tukey</span> <span class="n">sauter_poon</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Outlier rejection algorithm. If auto is selected, the&quot;</span>
                  <span class="s2">&quot;algorithm is chosen automatically.&quot;</span>
          <span class="o">.</span><span class="n">short_caption</span> <span class="o">=</span> <span class="s2">&quot;Outlier rejection algorithm&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">choice</span>
        <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Number of processes over which to split outlier&quot;</span>
                  <span class="s2">&quot;identification. If set to Auto, DIALS will choose&quot;</span>
                  <span class="s2">&quot;automatically.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">minimum_number_of_reflections</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The minimum number of input observations per outlier&quot;</span>
                  <span class="s2">&quot;rejection job below which all reflections in the job will&quot;</span>
                  <span class="s2">&quot;be rejected as potential outliers.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">separate_experiments</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If true, outlier rejection will be performed on each&quot;</span>
                  <span class="s2">&quot;experiment separately. Otherwise, the data from all&quot;</span>
                  <span class="s2">&quot;experiments will be combined for outlier rejection.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">separate_panels</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Perform outlier rejection separately for each panel of a&quot;</span>
                  <span class="s2">&quot;multi- panel detector model. Otherwise data from across all&quot;</span>
                  <span class="s2">&quot;panels will be combined for outlier rejection.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">separate_blocks</span> <span class="o">=</span> <span class="kc">True</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If true, for scans outlier rejection will be performed&quot;</span>
                  <span class="s2">&quot;separately in equal-width blocks of phi, controlled by the&quot;</span>
                  <span class="s2">&quot;parameter outlier.block_width.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">block_width</span> <span class="o">=</span> <span class="n">Auto</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If separate_blocks, a scan will be divided into equal-sized&quot;</span>
                  <span class="s2">&quot;blocks with width (in degrees) close to this value for&quot;</span>
                  <span class="s2">&quot;outlier rejection. If Auto, a width of at least 18 degrees&quot;</span>
                  <span class="s2">&quot;will be determined, such that each block contains enough&quot;</span>
                  <span class="s2">&quot;reflections to perform outlier rejection.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">separate_images</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If true, every image will be treated separately for outlier&quot;</span>
                  <span class="s2">&quot;rejection. It is a special case that will override both&quot;</span>
                  <span class="s2">&quot;separate_experiments and separate_blocks, and will set&quot;</span>
                  <span class="s2">&quot;these to False if required.&quot;</span>
          <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">tukey</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options for the tukey outlier rejector&quot;</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">iqr_multiplier</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The IQR multiplier used to detect outliers. A value of&quot;</span>
                    <span class="s2">&quot;1.5 gives Tukey&#39;s rule for outlier detection&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">mcd</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options for the mcd outlier rejector, which uses an&quot;</span>
                  <span class="s2">&quot;algorithm based on FAST-MCD by Rousseeuw and van Driessen.&quot;</span>
                  <span class="s2">&quot;See doi.org/10.1080/00401706.1999.10485670.&quot;</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Decimal fraction controlling the size of subsets over&quot;</span>
                    <span class="s2">&quot;which the covariance matrix determinant is minimised.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">max_n_groups</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The maximum number of groups to split the dataset into if&quot;</span>
                    <span class="s2">&quot;the dataset is &#39;large&#39; (more observations than twice the&quot;</span>
                    <span class="s2">&quot;min_group_size).&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">min_group_size</span> <span class="o">=</span> <span class="mi">300</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The smallest sub-dataset size when splitting the dataset&quot;</span>
                    <span class="s2">&quot;into a number of groups, maximally max_n_groups.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">n_trials</span> <span class="o">=</span> <span class="mi">500</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The number of samples used for initial estimates to seed&quot;</span>
                    <span class="s2">&quot;the search within each sub-dataset.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">k1</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;The number of concentration steps to take after initial&quot;</span>
                    <span class="s2">&quot;estimates.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">k2</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If the dataset is &#39;large&#39;, the number of concentration&quot;</span>
                    <span class="s2">&quot;steps to take after applying the best subset estimates to&quot;</span>
                    <span class="s2">&quot;the merged group.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">k3</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;If the dataset is &#39;small&#39;, the number of concentration&quot;</span>
                    <span class="s2">&quot;steps to take after selecting the best of the initial&quot;</span>
                    <span class="s2">&quot;estimates, applied to the whole dataset.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
          <span class="n">threshold_probability</span> <span class="o">=</span> <span class="mf">0.975</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Quantile probability from the Chi-squared distribution&quot;</span>
                    <span class="s2">&quot;with number of degrees of freedom equal to the number of&quot;</span>
                    <span class="s2">&quot;dimensions of the data data (e.g. 3 for X, Y and Phi&quot;</span>
                    <span class="s2">&quot;residuals). Observations whose robust Mahalanobis&quot;</span>
                    <span class="s2">&quot;distances are larger than the obtained quantile will be&quot;</span>
                    <span class="s2">&quot;flagged as outliers.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value_min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">value_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">sauter_poon</span>
          <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Options for the outlier rejector described in Sauter &amp; Poon&quot;</span>
                  <span class="s2">&quot;(2010) (https://doi.org/10.1107/S0021889810010782)&quot;</span>
          <span class="o">.</span><span class="n">expert_level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="p">{</span>
          <span class="n">px_sz</span> <span class="o">=</span> <span class="n">Auto</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;X, Y pixel size in mm. If Auto, this will be taken from&quot;</span>
                    <span class="s2">&quot;the first panel of the first experiment.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">floats</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">value_min</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>
          <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Verbose output.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">bool</span>
            <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">False</span>
          <span class="n">pdf</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="o">.</span><span class="n">help</span> <span class="o">=</span> <span class="s2">&quot;Output file name for making graphs of |dr| vs spot number&quot;</span>
                    <span class="s2">&quot;and dy vs dx.&quot;</span>
            <span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">str</span>
            <span class="o">.</span><span class="n">multiple</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">laue_dials</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributions &amp; Help</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/notebooks.html">Contents</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/notebooks.html#indices-and-tables">Indices and tables</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="functions.html">Command-Line Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="version.html">laue_dials.version</a></li>
<li class="toctree-l2"><a class="reference internal" href="find_spots.html">laue_dials.find_spots</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">laue_dials.index</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#basic-parameters">Basic parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#full-parameter-definitions">Full parameter definitions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="sequence_to_stills.html">laue_dials.sequence_to_stills</a></li>
<li class="toctree-l2"><a class="reference internal" href="optimize_indexing.html">laue_dials.optimize_indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="refine.html">laue_dials.refine</a></li>
<li class="toctree-l2"><a class="reference internal" href="predict.html">laue_dials.predict</a></li>
<li class="toctree-l2"><a class="reference internal" href="integrate.html">laue_dials.integrate</a></li>
<li class="toctree-l2"><a class="reference internal" href="plot_wavelengths.html">laue_dials.plot_wavelengths</a></li>
<li class="toctree-l2"><a class="reference internal" href="compute_rmsds.html">laue_dials.compute_rmsds</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api/modules.html">Full API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/tutorials.html">Jupyter Tutorials</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="functions.html">Functions</a><ul>
      <li>Previous: <a href="find_spots.html" title="previous chapter">laue_dials.find_spots</a></li>
      <li>Next: <a href="sequence_to_stills.html" title="next chapter">laue_dials.sequence_to_stills</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Rick Hewitt.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.1</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="../_sources/cli/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>